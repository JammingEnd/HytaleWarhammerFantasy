package com.jammingmods.plugin.UI;

import com.hypixel.hytale.codec.Codec;
import com.hypixel.hytale.codec.KeyedCodec;
import com.hypixel.hytale.codec.builder.BuilderCodec;
import com.hypixel.hytale.component.CommandBuffer;
import com.hypixel.hytale.component.Ref;
import com.hypixel.hytale.component.Store;
import com.hypixel.hytale.protocol.packets.interface_.CustomPageLifetime;
import com.hypixel.hytale.protocol.packets.interface_.CustomUIEventBindingType;
import com.hypixel.hytale.protocol.packets.interface_.Page;
import com.hypixel.hytale.server.core.Message;
import com.hypixel.hytale.server.core.entity.entities.Player;
import com.hypixel.hytale.server.core.entity.entities.player.pages.InteractiveCustomUIPage;
import com.hypixel.hytale.server.core.ui.builder.EventData;
import com.hypixel.hytale.server.core.ui.builder.UICommandBuilder;
import com.hypixel.hytale.server.core.ui.builder.UIEventBuilder;
import com.hypixel.hytale.server.core.universe.PlayerRef;
import com.hypixel.hytale.server.core.universe.world.storage.EntityStore;
import com.jammingmods.plugin.Components.FactionComponent;
import com.jammingmods.plugin.FactionTypes.FactionType;
import com.jammingmods.plugin.Readers.FactionTypeParser;
import com.jammingmods.plugin.WarhammerFantasyPlugin;

import javax.annotation.Nonnull;
import java.util.Arrays;
import java.util.Comparator;

// Generated by Hytale UI Builder (https://hytale.ellie.au).
// You may edit this class as necessary, or copy parts only.
public class CharacterSelectorUIPage extends InteractiveCustomUIPage<CharacterSelectorUIPage.BindingData> {

    private int selectedFactionIndex = 0;
    private int selectedSubtypeIndex = 0;
    private final FactionType[] availableFactions;
    private FactionType[] availableSubTypes;
    private FactionType selectedFaction;

    public CharacterSelectorUIPage(@Nonnull PlayerRef playerRef) {
        super(playerRef, CustomPageLifetime.CanDismissOrCloseThroughInteraction, BindingData.CODEC);

        // Load available factions
        availableFactions = FactionTypeParser.loadFactionTypes();
        loadSubTypes(availableFactions[0]);
    }
    public CharacterSelectorUIPage(@Nonnull PlayerRef playerRef, CharacterSelectorUIPage page) {
        super(playerRef, CustomPageLifetime.CanDismissOrCloseThroughInteraction, BindingData.CODEC);
        this.selectedFactionIndex = page.selectedFactionIndex;
        this.selectedSubtypeIndex = page.selectedSubtypeIndex;
        this.availableFactions = page.availableFactions;
        this.availableSubTypes = page.availableSubTypes;
        this.selectedFaction = page.selectedFaction;
    }

    private void loadSubTypes(FactionType type) {
        // Load available subtypes for the selected faction
        availableSubTypes = Arrays.stream(availableFactions)
                .filter(f -> f.category.equals(type.category))
                .sorted(Comparator.comparing(f -> f.name))
                .toArray(FactionType[]::new);
    }

    public static class BindingData {
        public String action;
        public static final BuilderCodec<BindingData> CODEC =
                BuilderCodec.builder(BindingData.class, BindingData::new)
                        .append(new KeyedCodec<>("Action", Codec.STRING),
                                (BindingData db, String v) -> db.action = v,
                                db -> db.action).add()
                        .build();
    }

    @Override
    public void build(@Nonnull Ref<EntityStore> ref, @Nonnull UICommandBuilder cmd, @Nonnull UIEventBuilder evt, @Nonnull Store<EntityStore> store) {
        cmd.append("Pages/WarhammerFantasy_CharacterSelector.ui");

        Player player = (Player) store.getComponent(ref, Player.getComponentType());
        player.sendMessage(Message.raw("availableFactions length:: " + availableFactions.length));

        // var config = MyPlugin.getInstance().config.get();
        if(availableFactions == null)
        {
            cmd.set("#FactionName.Text", "NULL :(");
        } else if (availableFactions.length == 0) {
            cmd.set("#FactionName.Text", "NOTHING :/");
        } else {
            // Update UI elements based on selected indices
            cmd.set("#FactionName.Text", availableFactions[selectedFactionIndex].category);
            cmd.set("#SubtypeName.Text", availableSubTypes[selectedSubtypeIndex].name);

            String BuffFormat = availableSubTypes[selectedSubtypeIndex].description + "\n\n";

            BuffFormat += "Traits:\n";
            for (var traitEntry : availableSubTypes[selectedSubtypeIndex].traits.entrySet()) {
                double value = traitEntry.getValue();
                String formatted = String.format("%.1f%%", value * 100);
                BuffFormat += "- " + traitEntry.getKey() + ": " + formatted + "\n";
            }

            cmd.set("#BuffLabel.Text", BuffFormat);
        }
        // cmd.set("#Description", availableSubTypes[selectedSubtypeIndex].description); -- WIP


        evt.addEventBinding(CustomUIEventBindingType.Activating, "#FactionPrevButton", EventData.of("Action", "PrevFaction"), false);
        evt.addEventBinding(CustomUIEventBindingType.Activating, "#FactionNextButton", EventData.of("Action", "NextFaction"), false);
        evt.addEventBinding(CustomUIEventBindingType.Activating, "#SubtypePrevButton", EventData.of("Action", "PrevSubtype"), false);
        evt.addEventBinding(CustomUIEventBindingType.Activating, "#SubtypeNextButton", EventData.of("Action", "NextSubtype"), false);
        evt.addEventBinding(CustomUIEventBindingType.Activating, "#ConfirmButton", EventData.of("Action", "Confirm"), false);
    }

    @Override
    public void handleDataEvent(@Nonnull Ref<EntityStore> ref, @Nonnull Store<EntityStore> store, @Nonnull BindingData data) {
        super.handleDataEvent(ref, store, data);
        Player player = (Player) store.getComponent(ref, Player.getComponentType());

            switch (data.action) {
                case "PrevFaction":
                    scrollFactions(-1);
                    break;
                case "NextFaction":
                    scrollFactions(1);
                    break;
                case "PrevSubtype":
                    scrollSubtypes(-1);
                    break;
                case "NextSubtype":
                    scrollSubtypes(1);
                    break;
                case "Confirm":
                    confirmSelection(ref, store);
                    return;
                default:
                    break;
            }
        updateUI(player, store, ref, playerRef);

    }

    private void scrollFactions(int direction) {
        if (availableFactions.length == 0) return;

        String currentCategory = availableFactions[selectedFactionIndex].category;
        int index = selectedFactionIndex;

        do {
            index += direction;

            // wrap around
            if (index < 0) {
                index = availableFactions.length - 1;
            } else if (index >= availableFactions.length) {
                index = 0;
            }

        } while (availableFactions[index].category.equals(currentCategory));

        selectedFactionIndex = index;
        selectedSubtypeIndex = 0; // reset subtype when changing faction

        selectedFaction = availableFactions[selectedFactionIndex];

        loadSubTypes(selectedFaction);
    }
    private void scrollSubtypes(int direction) {
        // Update selectedSubtypeIndex based on direction (-1 for previous, 1 for next)
        int newIndex = selectedSubtypeIndex + direction;
        if (newIndex < 0) {
            newIndex = availableSubTypes.length - 1;
        } else if (newIndex >= availableSubTypes.length) {
            newIndex = 0;
        }

        selectedSubtypeIndex = newIndex;
        selectedFaction = availableSubTypes[selectedSubtypeIndex];
    }

    private void confirmSelection(@Nonnull Ref<EntityStore> ref, @Nonnull Store<EntityStore> store) {
        // Handle confirmation of the selected faction and subtype
        Player player = (Player) store.getComponent(ref, Player.getComponentType());

        player.sendMessage(Message.raw("Confirming selection..."));

        FactionComponent faction = new FactionComponent(
                selectedFaction.TYPE_ID,
                selectedFaction.category,
                selectedFaction.name,
                selectedFaction.description,
                selectedFaction.traits
        );

        if(store.getComponent(ref, WarhammerFantasyPlugin.FACTION_COMPONENT_TYPE) != null) {
            player.sendMessage(Message.raw("Updating existing faction..."));
            var component = store.ensureAndGetComponent(ref, WarhammerFantasyPlugin.FACTION_COMPONENT_TYPE);
            component.Update(faction);
        }
        else {
            store.putComponent(ref, WarhammerFantasyPlugin.FACTION_COMPONENT_TYPE, faction);
            String message = "You Became a " + faction.GetSubtypeName() + "!" + " | other info: " + faction.getFactionId();
            player.sendMessage(Message.raw(message));
        }
        store.saveAllResources();
        this.close();
    }

    private void updateUI(Player player, Store<EntityStore> store, Ref<EntityStore> ref, PlayerRef playerRef) {
        CharacterSelectorUIPage newPage = new CharacterSelectorUIPage(playerRef, this);
        player.getPageManager().openCustomPage(ref, store, newPage);
    }

}
